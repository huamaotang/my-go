# 测试函数
## 基础知识
- 每个测试函数必须导入testing包；测试函数的签名：

```
func TestName(t *testing.T) {
    // ...
}
```
- 测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头

```
func TestSin(t *testing.T) { /* ... */ }
func TestCos(t *testing.T) { /* ... */ }
func TestLog(t *testing.T) { /* ... */ }
```
- 参数t用于报告测试失败和附加的日志管理
- go test

## 代码示例（回文校验）

### gopl.io/ch11/word1
```
// Package word provides utilities for word games.
package word

// IsPalindrome reports whether s reads the same forward and backward.
// (Our first attempt.)
func IsPalindrome(s string) bool {
    for i := range s {
        if s[i] != s[len(s)-1-i] {
            return false
        }
    }
    return true
}
```
### word_test.go

```
package word

import "testing"

func TestPalindrome(t *testing.T) {
    if !IsPalindrome("detartrated") {
        t.Error(`IsPalindrome("detartrated") = false`)
    }
    if !IsPalindrome("kayak") {
        t.Error(`IsPalindrome("kayak") = false`)
    }
}

func TestNonPalindrome(t *testing.T) {
    if IsPalindrome("palindrome") {
        t.Error(`IsPalindrome("palindrome") = true`)
    }
}
```
- `go test`命令如果没有参数指定包，则默认采用当前目录对应的包（和`go build`一样）

### 代码BUG
- “été”、“A man, a plan, a canal: Panama.”不能被识别

```
func TestFrenchPalindrome(t *testing.T) {
    if !IsPalindrome("été") {
        t.Error(`IsPalindrome("été") = false`)
    }
}

func TestCanalPalindrome(t *testing.T) {
    input := "A man, a plan, a canal: Panama"
    if !IsPalindrome(input) {
        t.Errorf(`IsPalindrome(%q) = false`, input)
    }
}
```
- 原因：采用了byte类型，而不是rune序列，非ASCLL字符不能被正确处理；字母大小写；没有忽略非字母字符

### gopl.io/ch11/word2
```
// Package word provides utilities for word games.
package word

import "unicode"

// IsPalindrome reports whether s reads the same forward and backward.
// Letter case is ignored, as are non-letters.
func IsPalindrome(s string) bool {
    var letters []rune
    for _, r := range s {
        if unicode.IsLetter(r) {
            letters = append(letters, unicode.ToLower(r))
        }
    }
    for i := range letters {
        if letters[i] != letters[len(letters)-1-i] {
            return false
        }
    }
    return true
}
```
### 表格驱动测试（测试数据合并到一个测试表格中，便于构建精心挑选的测试用例）

```
func TestIsPalindrome(t *testing.T) {
    var tests = []struct {
        input string
        want  bool
    }{
        {"", true},
        {"a", true},
        {"aa", true},
        {"ab", false},
        {"kayak", true},
        {"detartrated", true},
        {"A man, a plan, a canal: Panama", true},
        {"Evil I did dwell; lewd did I live.", true},
        {"Able was I ere I saw Elba", true},
        {"été", true},
        {"Et se resservir, ivresse reste.", true},
        {"palindrome", false}, // non-palindrome
        {"desserts", false},   // semi-palindrome
    }
    for _, test := range tests {
        if got := IsPalindrome(test.input); got != test.want {
            t.Errorf("IsPalindrome(%q) = %v", test.input, got)
        }
    }
}
```
- 表格驱动的测试在Go语言中很常见，可以很容易向表格添加新的测试数据
- t.Errorf调用没有引起panic异常或停止测试的执行
- 如果需要停止当前测试函数，可以调用t.Fatal或t.Fatalf，它们必须和测试函数在同一个goroutine内调用
- 测试失败的形式`f(x)=y, want z`，这里忽略了z（布尔类型）

## 随机测试
- 通过构造更广泛的随机输入来测试探索函数的行为
- 对于一个随机输入，如何能知道希望的输出结果呢？两种策略
	- 编写另一个对照函数，使用简单和清晰的算法，针对相同的随机输入检查两者的输出结果
	- 生成随机输入的数据遵循特定的模式
	
		```
		import "math/rand"

		// randomPalindrome returns a palindrome whose length and contents
		// are derived from the pseudo-random number generator rng.
		func randomPalindrome(rng *rand.Rand) string {
		    n := rng.Intn(25) // random length up to 24
		    runes := make([]rune, n)
		    for i := 0; i < (n+1)/2; i++ {
		        r := rune(rng.Intn(0x1000)) // random rune up to '\u0999'
		        runes[i] = r
		        runes[n-1-i] = r
		    }
		    return string(runes)
		}
		
		func TestRandomPalindromes(t *testing.T) {
		    // Initialize a pseudo-random number generator.
		    seed := time.Now().UTC().UnixNano()
		    t.Logf("Random seed: %d", seed)
		    rng := rand.New(rand.NewSource(seed))
		
		    for i := 0; i < 1000; i++ {
		        p := randomPalindrome(rng)
		        if !IsPalindrome(p) {
		            t.Errorf("IsPalindrome(%q) = false", p)
		        }
		    }
		}
		```
- 通过当前时间作为随机种子，每次运行测试命令时都将探索新的随机数据		

